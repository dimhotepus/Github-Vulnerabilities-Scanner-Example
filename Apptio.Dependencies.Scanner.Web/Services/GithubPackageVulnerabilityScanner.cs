using System;
using System.Collections.Generic;
using System.Linq;
using System.Net.Http;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using Apptio.Dependencies.Scanner.Web.Constants;
using Apptio.Dependencies.Scanner.Web.Dtos;
using Apptio.Dependencies.Scanner.Web.Exceptions;
using Apptio.Dependencies.Scanner.Web.Models;
using JetBrains.Annotations;
using Microsoft.Extensions.Logging;
using SemVersion;

namespace Apptio.Dependencies.Scanner.Web.Services
{
    public class GithubPackageVulnerabilityScanner : IPackageVulnerabilityScanner
    {
        private const string ApiUrl = "https://api.github.com/graphql";

        private const string VulnerabilitiesQuery_Ecosystem_First_After_PackageName = @"{
    ""query"": ""query {
        securityVulnerabilities(ecosystem: {0}, first: {1}, after: \""{2}\"", package: \""{3}\"") {
            pageInfo {
                endCursor
                hasNextPage
            }
            nodes {
                severity
                advisory {
                    permalink
                }
                package {
                    name
                    ecosystem
                }
                vulnerableVersionRange
                firstPatchedVersion {
                    identifier
                }
            }
        }
    }""
}";

        private readonly HttpClient _httpClient;
        private readonly ILogger<GithubPackageVulnerabilityScanner> _logger;
        private readonly JsonSerializerOptions _jsonSerializerOptions;

        public GithubPackageVulnerabilityScanner(HttpClient httpClient,
            ILogger<GithubPackageVulnerabilityScanner> logger)
        {
            _httpClient = httpClient;
            _logger = logger;
            _jsonSerializerOptions = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
        }

        public IEnumerable<Ecosystem> SupportedEcosystems
        {
            get { yield return Ecosystem.Npm; }
        }

        public async Task<(
            List<VulnerablePackageDto> VulnerablePackages,
            List<FailedScanPackageDto> FailedScanPackages
            )> Scan(IDependencyPackages deps, CancellationToken cancellationToken)
        {
            if (deps == null) throw new ArgumentNullException(nameof(deps));
            if (!SupportedEcosystems.Contains(deps.Ecosystem))
            {
                throw new UnknownEcosystemException(deps.Ecosystem);
            }

            var dependencyPackages = deps.Values();
            var scanQueries = dependencyPackages
                .Select(dependencyPackage =>
                    Scan
                    (
                        dependencyPackage.Key,
                        dependencyPackages[dependencyPackage.Key],
                        deps.Ecosystem,
                        cancellationToken
                    )
                )
                .ToArray();
            var scanResults = await Task.WhenAll(scanQueries);

            var failedScanPackages = new List<FailedScanPackageDto>();
            var semVerRangeParser = new SemVersion.Parser.RangeParser();
            var vulnerablePackages = scanResults
                .Aggregate(new List<VulnerablePackageDto>(), (result, packageInfo) =>
                {
                    var (packageName, vulnerabilities, failedScanPackage) = packageInfo;

                    if (failedScanPackage != null)
                    {
                        failedScanPackages.Add(failedScanPackage);
                    }

                    if (vulnerabilities == null || vulnerabilities.Length == 0)
                    {
                        return result;
                    }

                    result.AddRange(
                        from vulnerabilityInfo in vulnerabilities
                        let parserVersionRange = vulnerabilityInfo.VulnerableVersionRange.Replace(", ", " && ")
                        let isVersionVulnerable = semVerRangeParser.Evaluate(parserVersionRange)
                        let rawDependencyVersion = dependencyPackages[packageName]
                        let parsedDependencyVersion = SemanticVersion.Parse(rawDependencyVersion)
                        where isVersionVulnerable(parsedDependencyVersion)
                        select new VulnerablePackageDto
                        {
                            Name = vulnerabilityInfo.Package.Name,
                            Version = rawDependencyVersion,
                            Severity = vulnerabilityInfo.Severity,
                            AdvisoryLink = vulnerabilityInfo.Advisory?.Permalink,
                            FirstPatchedVersion = vulnerabilityInfo.FirstPatchedVersion?.Identifier
                        }
                    );
                    return result;
                });
            return (VulnerablePackages: vulnerablePackages, FailedScanPackages: failedScanPackages);
        }

        private async Task<(
            string PackageName,
            PackageVulnerabilityInfoDto[] VulnerablePackages,
            FailedScanPackageDto FailedScanPackage
            )> Scan(string packageName, string packageVersion, Ecosystem ecosystem, CancellationToken cancellationToken)
        {
            var vulnerablePackages = new List<PackageVulnerabilityInfoDto>();
            FailedScanPackageDto failedScanPackageDto = null;
            string startCursor = null;
            bool hasNextPage;

            do
            {
                var (vps, fsp, newStartCursor, newHasNextPage) =
                    await ScanPage(packageName, packageVersion, ecosystem, startCursor, cancellationToken);

                vulnerablePackages.AddRange(vps);

                if (failedScanPackageDto == null && fsp != null)
                {
                    // First scan failure for package is returned.
                    failedScanPackageDto = fsp;
                }

                startCursor = newStartCursor;
                hasNextPage = newHasNextPage;
            } while (hasNextPage);

            return (
                PackageName: packageName,
                VulnerablePackages: vulnerablePackages.ToArray(),
                FailedScanPackage: failedScanPackageDto
            );
        }

        private async Task<(
            PackageVulnerabilityInfoDto[] VulnerablePackages,
            FailedScanPackageDto FailedScanPackage,
            string StartCursor,
            bool HasNextPage
            )> ScanPage(string packageName, string packageVersion,
            Ecosystem ecosystem, [CanBeNull] string afterCursor, CancellationToken cancellationToken)
        {
            var content = MakeGraphQlQueryContent(packageName, ecosystem, afterCursor);

            var response = await _httpClient.PostAsync(ApiUrl, content, cancellationToken);
            if (!response.IsSuccessStatusCode)
            {
                var mayBeJsonMessage = await response.Content.ReadAsStringAsync(cancellationToken);
                if (response.Content.Headers.ContentType?.MediaType == KnownContentTypes.ApplicationJson)
                {
                    // Is it safe to expose to client?
                    mayBeJsonMessage = JsonSerializer
                                           .Deserialize<ErrorQueryResponseDto>(mayBeJsonMessage, _jsonSerializerOptions)
                                           ?.Message ??
                                       mayBeJsonMessage;
                }

                _logger.LogError(
                    "Unable to query vulnerability info for {package} from Github: HTTP {statusCode}, Reason: {reason}, Body: {body}",
                    packageName, response.StatusCode, response.ReasonPhrase,
                    mayBeJsonMessage);

                return GetFailedScanPackage(packageName, packageVersion, mayBeJsonMessage);
            }

            var responseBody = await response.Content.ReadAsStreamAsync(cancellationToken);
            var packageVulnerabilities = await JsonSerializer
                .DeserializeAsync<VulnerabilitiesQueryResponseDto>(responseBody, _jsonSerializerOptions,
                    cancellationToken);
            if (packageVulnerabilities == null)
            {
                return GetFailedScanPackage(packageName, packageVersion,
                    "Github vulnerability query returns no results.");
            }

            if (packageVulnerabilities.Errors != null && packageVulnerabilities.Errors.Length != 0)
            {
                // Just return first error.
                return GetFailedScanPackage(packageName, packageVersion,
                    packageVulnerabilities.Errors.First().Message);
            }

            if (!packageVulnerabilities.Data.HasValue)
            {
                return GetFailedScanPackage(packageName, packageVersion,
                    "Github vulnerability query returns no results.");
            }

            // Assume Github doesn't change response data format.
            // GraphQL queries are designed to shape the responses, so likely they break queries first.
            var vulnerabilitiesJson = packageVulnerabilities.Data.Value.GetProperty("securityVulnerabilities");

            var pageInfoJson = vulnerabilitiesJson.GetProperty("pageInfo");
            var pageInfo =
                JsonSerializer.Deserialize<PageInfoQueryResponseDto>(pageInfoJson.GetRawText(), _jsonSerializerOptions);
            if (pageInfo == null)
            {
                return GetFailedScanPackage(packageName, packageVersion,
                    "Github vulnerability query returns no paging info results.");
            }

            var nodesJson = vulnerabilitiesJson.GetProperty("nodes");
            var vulnerablePackages =
                JsonSerializer.Deserialize<PackageVulnerabilityInfoDto[]>(nodesJson.GetRawText(),
                    _jsonSerializerOptions);
            return (
                VulnerablePackages: vulnerablePackages,
                FailedScanPackage: null,
                StartCursor: pageInfo.EndCursor,
                pageInfo.HasNextPage
            );
        }

        private static StringContent MakeGraphQlQueryContent(string packageName, Ecosystem ecosystem,
            [CanBeNull] string afterCursor)
        {
            return new StringContent(
                // The string value of "query" must escape newline characters or the schema will not parse it correctly.
                VulnerabilitiesQuery_Ecosystem_First_After_PackageName
                    .Replace("{0}", ecosystem.ToString().ToUpper())
                    .Replace("{1}", "50")
                    .Replace(@"after: \""{2}\"", ",
                        afterCursor != null ? $@"after: \""{afterCursor}\"", " : string.Empty)
                    .Replace("{3}", packageName.Replace("\n", "\\n"))
                    .Replace('\r', ' ')
                    .Replace('\n', ' '),
                null,
                KnownContentTypes.ApplicationJson);
        }

        private static (
            PackageVulnerabilityInfoDto[] VulnerablePackages,
            FailedScanPackageDto FailedScanPackage,
            string StartCursor,
            bool HasNextPage
            ) GetFailedScanPackage(string packageName, string packageVersion, string message)
        {
            var failedScanPackage = new FailedScanPackageDto
            {
                Name = packageName,
                Version = packageVersion,
                Error = new ScanErrorDto
                {
                    Code = KnownErrorCodes.Scan.InternalScannerFailure,
                    Message = message
                }
            };
            return (
                VulnerablePackages: Array.Empty<PackageVulnerabilityInfoDto>(),
                FailedScanPackage: failedScanPackage,
                StartCursor: null,
                HasNextPage: false
            );
        }

        // ReSharper disable once ClassNeverInstantiated.Global
        public class PackageDto
        {
            public string Name { get; set; }
        }

        // ReSharper disable once ClassNeverInstantiated.Global
        public class FirstPatchedVersionDto
        {
            [NotNull] public string Identifier { get; set; }
        }

        // ReSharper disable once MemberCanBePrivate.Global
        // ReSharper disable once ClassNeverInstantiated.Global
        public class PackageVulnerabilityInfoDto
        {
            [NotNull] public string Severity { get; set; }
            [CanBeNull] public AdvisoryQueryResponseDto Advisory { get; set; }
            [NotNull] public PackageDto Package { get; set; }
            [NotNull] public string VulnerableVersionRange { get; set; }
            [CanBeNull] public FirstPatchedVersionDto FirstPatchedVersion { get; set; }
        }

        // ReSharper disable once ClassNeverInstantiated.Global
        public class AdvisoryQueryResponseDto
        {
            public string Permalink { get; set; }
        }

        // ReSharper disable once ClassNeverInstantiated.Global
        public class ErrorQueryResponseDto
        {
            [NotNull] public string Message { get; set; }
        }

        public class VulnerabilitiesQueryResponseDto
        {
            public JsonElement? Data { get; set; }
            [CanBeNull] public ErrorQueryResponseDto[] Errors { get; set; }
        }

        public class PageInfoQueryResponseDto
        {
            [NotNull] public string EndCursor { get; set; }
            public bool HasNextPage { get; set; }
        }
    }
}